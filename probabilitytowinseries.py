# -*- coding: utf-8 -*-
"""ProbabilityToWinSeries.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/113Fi-rNvh-K3t47o_nOAoZ_-YEFDHXpJ
"""

from manim import *
import math
import numpy as np
from manim_slides import *
import random
#from MF_Tools import *
import os
os.environ["PATH"] = "/Library/TeX/texbin:" + os.environ["PATH"]

## Global Variables and Stuff ##
#config.media_embed = True
DELAY = 0.1

# latex preamble
texPre = TexTemplate()
texPre.add_to_preamble(r"""
    \usepackage{amsmath}
    \usepackage{amssymb}
    \newcommand{\E}{\mathbb{E}}
    \newcommand{\P}{\mathbb{P}}
    \newcommand{\vect}[1]{\mathbf{#1}}
""")

# tex color dictionary
E_color = GREY_B
n_color = BLUE_C
T_color = ORANGE
F_color = PURPLE_A
k_color = GREEN

x_color = BLUE
y_color = RED
t_color = GREEN

t2cD = {
    "X" : x_color,
    "Y" : y_color,
    " x": x_color,
    " y": y_color,
    "_t ": t_color,
    "P ": PURPLE,
}

# font sizes
my_fs = 75

#other colors

house_color = WHITE
dot_color = WHITE
edge_color = BLUE

# Commented out IPython magic to ensure Python compatibility.
# %%manim -ql -v WARNING FractionGrid

class FractionGrid(Slide): #self.next_slide() #comment in for manim-slides
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.skip_reversing = True
    def pause(self):
        self.wait(DELAY)
        self.next_slide() #comment in for manim-slides
    
    def construct(self):
        # Define fraction grid as LaTeX strings
        #fraction_grid = [
        #    ["0", "0", "0", "0",  "0"],
        #    ["\\frac{1}{16}", "\\frac{1}{8}", "\\frac{1}{4}", "\\frac{1}{2}", "1"],
        #    ["\\frac{6}{32}", "\\frac{5}{16}", "\\frac{4}{8}", "\\frac{3}{4}", "1"],
        #    ["\\frac{22}{64}", "\\frac{16}{32}", "\\frac{11}{16}", "\\frac{7}{8}", "1"],
        #    ["\\frac{1}{2}", "\\frac{42}{64}", "\\frac{26}{32}", "\\frac{15}{16}", "1"]
        #]
        fraction_grid = [
           ["0", "0", "0", "0",  "0"],
           ["{1 \\over 16}", "{1 \\over 8}", "{1 \\over 4}", "{1 \\over 2}", "1"],
           ["{6 \\over 32}", "{5 \\over 16}", "{4 \\over 8}", "{3 \\over 4}", "1"],
           ["{22 \\over 64}", "{16 \\over 32}", "{11 \\over 16}", "{7 \\over 8}", "1"],
           ["{64 \\over 128}", "{42 \\over 64}", "{26 \\over 32}", "{15 \\over 16}", "1"]
        ]

        delta_grid = [
            [".", ".", ".", ".",  "."],
            ["{1 \\over 16}", "{1 \\over 8}", "{1 \\over 4}", "{1 \\over 2}", "."],
            ["{1 \\over 8}", "{3 \\over 16}", "{1 \\over 4}", "{1 \\over 4}", "."],
            ["{5 \\over 32}", "{3 \\over 16}", "{3 \\over 16}", "{1 \\over 8}", "."],
            ["{5 \\over 32}", "{5 \\over 32}", "{1 \\over 8}", "{1 \\over 16}", "."]
        ]

        rows = len(fraction_grid)
        cols = len(fraction_grid[0])
        #print(rows,cols)
        box_size = 1.2
        frac_fs = 36
        label_fs = 32
        grid_color = GREY_D

        grid = VGroup()
        fracs = VGroup()
        for i in range(rows):
            row_grid = VGroup()
            row_fracs = VGroup()
            for j in range(cols):
                # Create fixed-size square
                square = Square(side_length=box_size,color=grid_color)
                square.move_to(RIGHT * j * box_size + DOWN * i * box_size)

                # Create fraction and center it in the square
                frac = MathTex(fraction_grid[i][j],font_size=frac_fs)
                frac.move_to(square.get_center())
                if j == cols-1 or i == 0:
                    frac.scale(1.5)

                # Group together
                #cell = VGroup(square, frac).copy()
                #frac.set_opacity(0)
                row_grid.add(square)
                row_fracs.add(frac)
            grid.add(row_grid)
            fracs.add(row_fracs)

        # Center the whole grid
        VGroup(grid,fracs).move_to(ORIGIN)

        # Column labels: 0 to 4 (under each column)
        col_labels = VGroup()
        for j in range(cols):
            label = MathTex("X","=",str(j),tex_to_color_map=t2cD,font_size=label_fs)
            label[2].set_color(x_color)
            label.next_to(grid[-1][j], DOWN)
            #x = grid[0][j].get_center()[0]
            #y = grid[-1][j][0].get_bottom()[1] - 0.4  # get bottom of square
            #label.move_to([x, y, 0])
            col_labels.add(label)

        # Row labels: 4 to 0 (left of each row)
        row_labels = VGroup()
        for i in range(rows):
            label = MathTex("Y","=",str(rows - 1 - i),tex_to_color_map=t2cD,font_size=label_fs)
            label[2].set_color(y_color)
            label.next_to(grid[i][0], LEFT)
            #y = grid[i][0].get_center()[1]
            #x = grid[i][0][0].get_left()[0] - 0.4  # get left of square
            #label.move_to([x, y, 0])
            row_labels.add(label)

        grid[0][-1].set_opacity(0)
        fracs[0][-1].set_opacity(0)

        # Add everything to the scene
        title_scale = 0.85
        title = MathTex(r"\text{Probability Team}", r"X",r"\text{ wins series, given series is at }", r" x",r"\text{ to }", r" y",tex_to_color_map=t2cD).scale(title_scale)
        title.to_edge(UP,buff=0.3)
        title.to_corner(UL,buff=0.3)
        title_u = Underline(title)
        self.add(title,title_u)
        #self.wait()

        ab_scale = 1.3

        # Top box with 'a'
        top_box = Square(side_length=box_size,color=grid_color)
        a_tex = MathTex("a").scale(ab_scale).move_to(top_box.get_center())
        top = VGroup(top_box, a_tex)

        # Bottom-left box with (a + b)/2
        left_box = Square(side_length=box_size,color=grid_color)
        avg_tex = MathTex(r"a", r"+", r"b", r"\over", r"2").scale(0.8).move_to(left_box.get_center())
        left = VGroup(left_box, avg_tex)

        # Bottom-right box with 'b'
        right_box = Square(side_length=box_size,color=grid_color)
        b_tex = MathTex("b").scale(ab_scale).move_to(right_box.get_center())
        right = VGroup(right_box, b_tex)

        # Position boxes into L-shape
        left.move_to(DOWN * box_size)
        right.move_to(DOWN * box_size + RIGHT * box_size)
        #top.move_to(UP * box_size * 0.5 + RIGHT * box_size * 0.5)  # Centered above avg & b

        # Combine all into a VGroup
        l_shape = VGroup(top, left, right).move_to(ORIGIN)
        l_shape.to_corner(UR)
        l_shape.align_to(grid[0][0],UP)
        #self.add(l_shape)

        #self.wait()
        delta_fs = 25
        delta_color = TEAL
        my_buff = 0.07
        deltas = VGroup()
        for i in range(rows):
            delta_row = VGroup()
            for j in range(cols):
                #self.add(fracs[i][j])
                delta = MathTex(delta_grid[i][j],font_size=delta_fs,color=delta_color)
                delta.move_to(grid[i][j].get_center())
                delta.align_to(grid[i][j],UP)
                delta.shift(DOWN*my_buff)
                delta.align_to(grid[i][j],RIGHT)
                delta.shift(LEFT*my_buff)
                delta_row.add(delta)
            deltas.add(delta_row)
        #self.add(deltas)
        #return 0


        comment = ImageMobject("trefor.png")
        tree = ImageMobject("GameTree.png")
        tree.set_width(config.frame_width / 2.15)
        comment.set_height(tree.height)
        comment.to_corner(DR,buff=0.3)
        #comment.shift(LEFT*0.2)
        tree.next_to(comment,LEFT,buff=0.0)
        #tree.to_corner(DL,buff=0.3)

        #both = Group(comment,tree).arrange(RIGHT).to_edge(DOWN)
        self.add(comment)

        bonus = MathTex(r"\text{Bonus: How to create a bet on series from bets on single games?}").scale(title_scale)
        bonus.next_to(title,DOWN,buff=0.3)
        bonus.to_edge(LEFT,buff=0.3)
        #self.add(bonus)
        #comment.set_z_index(-1)
        #comment.next_to(line1,DOWN)
        #comment.to_edge(LEFT)

        #return

        #self.next_section(skip_animations=True)
        #self. grid, col_labels, row_labels)



        self.pause()

        self.play(FadeIn(tree))
        self.pause()

        self.play(Write(bonus))
        self.pause()


        #self.next_section()

        self.play(
            FadeOut(bonus,tree,comment),
            LaggedStart(*[Write(mob) for mob in row_labels+col_labels], lag_ratio=0.5),
            #LaggedStart(*[Write(mob) for mob in col_labels], lag_ratio=0.8),
        )
        self.play(LaggedStart(*[Create(grid[i][j]) for i in range(rows) for j in range(cols)], lag_ratio=0.1))
        self.pause()

        self.play(LaggedStart(*[FadeIn(fracs[0][i],shift=RIGHT) for i in range(cols-1)], lag_ratio=0.5))
        self.pause()

        self.play(LaggedStart(*[FadeIn(fracs[i+1][-1],shift=DOWN) for i in range(cols-1)], lag_ratio=0.5))
        self.pause()


        pre_boxes = VGroup(grid[0][3],grid[1][3],grid[1][4]).copy()
        post_boxes = VGroup(top_box, left_box, right_box)

        update_text = MathTex(r"\text{Update Rule:}").scale(0.9)
        update_text.next_to(post_boxes,UP)
        update_text.to_edge(UP,buff=0.3)
        update_text_u = Underline(update_text)




        self.play(
            ReplacementTransform(pre_boxes,post_boxes,path_arc=PI/2),
            FadeIn(update_text,shift=RIGHT),
            Create(update_text_u)
        )
        self.play(LaggedStart(FadeIn(a_tex,shift=UP), FadeIn(b_tex,shift=RIGHT), lag_ratio=0.5))
        self.pause()

        #self.next_section()
        #a_b_tex = MathTex("a","b",tex_to_color_map=t2cD)
        #a_b_tex[0].move_to(a_tex)
        #a_b_tex[1].move_to(b_tex)
        #self.add(a_b_tex)
        #self.play(ReplacementTransform(VGroup(a_tex,b_tex).copy(),avg_tex))
        print(*enumerate(avg_tex),sep="\n")
        self.play(
            ReplacementTransform(a_tex.copy(), avg_tex[0]),
            ReplacementTransform(b_tex.copy(), avg_tex[2]),
            GrowFromCenter(avg_tex[1]),
            GrowFromCenter(avg_tex[3]),
            GrowFromCenter(avg_tex[4])
        )
        self.pause()


        eqn_fs = 30
        eqnRHS = MathTex(r"{", f"p(", r" x", r"\!+\!1", r",", r" y", r")", r"+", f"p(", r" x", r",", r" y",r"\!+\!1", r")"  , r"}", r"\over", r"2", font_size=eqn_fs, tex_to_color_map=t2cD)
        eqnEQ = MathTex(r"=",font_size=eqn_fs).move_to(eqnRHS.get_center()).scale(ab_scale)
        eqnLHS = MathTex(f"p(", r" x", r",", r" y", r")", font_size=eqn_fs, tex_to_color_map=t2cD).scale(ab_scale)
        eqn = VGroup(eqnLHS,eqnEQ,eqnRHS).arrange(DOWN)
        eqn.next_to(post_boxes,DOWN,buff=0.5)
        self.play(
            ReplacementTransform(post_boxes.copy(),eqnEQ),
            ReplacementTransform(avg_tex.copy(),eqnRHS),
            ReplacementTransform(VGroup(a_tex,b_tex).copy(),eqnLHS),
        )
        self.pause()

        for i in range(4):
            pre = VGroup(fracs[1][4-i],fracs[0][3-i]).copy()
            self.play(ReplacementTransform(pre, fracs[1][3-i]))
            self.pause()


        for j in range(3):
            pre = VGroup(fracs[j+1][3],fracs[j+2][4]).copy()
            self.play(ReplacementTransform(pre, fracs[j+2][3]))
            #self.pause()
        self.pause()

        for i in range(3):
            pre = VGroup(fracs[2][3-i],fracs[1][2-i]).copy()
            self.play(ReplacementTransform(pre, fracs[2][2-i]))
            #self.pause()
        self.pause()


        for j in range(2):
            pre = VGroup(fracs[j+2][2],fracs[j+3][3]).copy()
            self.play(ReplacementTransform(pre, fracs[j+3][2]))
            #self.pause()
        self.pause()

        for i in range(2):
            pre = VGroup(fracs[3][2-i],fracs[2][1-i]).copy()
            self.play(ReplacementTransform(pre, fracs[3][1-i]))
            #self.pause()
        self.pause()


        pre = VGroup(fracs[3][1],fracs[4][2]).copy()
        self.play(ReplacementTransform(pre, fracs[4][1]))
        self.pause()

        pre = VGroup(fracs[4][1],fracs[3][0]).copy()
        self.play(ReplacementTransform(pre, fracs[4][0]))
        self.pause()

        self.next_section()

        bonus.to_corner(UL,buff=0.3)
        bonus_u = Underline(bonus)
        self.play(
            FadeOut(title,shift=RIGHT),
            FadeOut(update_text,shift=RIGHT),
            FadeOut(update_text_u,shift=RIGHT),
            Write(bonus),
            Create(bonus_u)
        )
        self.remove(title_u)


        self.play(GrowFromPoint(deltas[1][3],fracs[1][3].get_center()))
        self.pause()

        anim_group = []
        for i in range(1,5):
            for j in range(4):
                if i == 1 and j == 3:
                    continue
                anim_group.append(GrowFromPoint(deltas[i][j],fracs[i][j].get_center()))
        self.play(LaggedStart(*anim_group),lag_ratio=0.8)
        self.pause()

        doob_fs = 60
        doobRHS =  MathTex(r"\mathbb{P}(\text{Team}X\text{ wins}| X_t , Y_t )", font_size=doob_fs, tex_to_color_map=t2cD)
        doobEQ = MathTex(r"=",font_size=doob_fs).move_to(doobRHS.get_center()) #.scale(ab_scale)
        doobLHS = MathTex(r"P ", r"_t ", font_size=doob_fs, tex_to_color_map=t2cD) #.scale(ab_scale)
        #doobLHS[0].set_color(PURPLE)
        doob = VGroup(doobLHS,doobEQ,doobRHS).arrange(RIGHT)
        doob.to_corner(UL,buff=0.3)
        doob.set_x(grid.get_x())
        #doob.next_to(post_boxes,DOWN,buff=0.5)
        self.play(
            FadeOut(bonus, shift=UP),
            FadeOut(bonus_u, shift=UP),
            ReplacementTransform(eqnLHS.copy(),doobLHS),
            ReplacementTransform(eqnEQ.copy(),doobEQ),
            ReplacementTransform(eqnRHS.copy(),doobRHS),
        )
        self.pause()





        self.wait(2)



